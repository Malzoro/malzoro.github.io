+++
title = 'Stack String Manipulation'
date = 2023-09-22T10:47:23-04:00
description = 'In this post I will explain string manipulation on the stack, using shellcoding as an example.'
draft = false
+++

So we've seen many of the ways we could want to manipulate strings for our shellcode, this time let's use a previous technique to call `execve("/bin/sh")`.

Let's write our program.
```nasm
.intel_syntax noprefix
.global _start

.section .text

_start:
  mov rbx, 0x0068732f6e69622f
  push rbx
  mov rdi, rsp
  xor eax, eax
  mov al, 59
  syscall
```

We used the string `/bin/sh\0` backward, we could also do the following instead.
```nasm
.intel_syntax noprefix
.global _start

.section .text

_start:
  mov rbx, 0x68732f2f6e69622f
  push rbx
  mov rdi, rsp
  xor eax, eax
  mov al, 59
  syscall
```

This time we're calling `execve` with `/bin//sh`, note that we're just trying to make the value fit in 8 bytes, so we added an extra `/`, this has no consequences and work just like when not using the extra `/`.

However please note that since we didn't specify a null-byte at the end of the second program, it might not always work, for example. When i compiled the second program, it was trying to run `/bin//sh\1` instead of `/bin//sh\0` which was failing.

## Do we need to exit() when calling execve
The eagle-eyed may have notice that i did not use the `exit()` system call after calling `execve`, that's because `execve` is wiping the current process data section and memory (stack, heap).

So calling exit, after a `execve` call is not required, matter of fact it's bytes that could be removed from your shellcode.
